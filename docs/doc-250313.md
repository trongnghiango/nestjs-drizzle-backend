Trong NestJS, **interceptor** và **filter** đều là hai khái niệm quan trọng để xử lý các yêu cầu và phản hồi, nhưng chúng phục vụ những mục đích khác nhau. Dưới đây là cách phân biệt chúng:

### Interceptor

1. **Mục Đích**:
    - Interceptor được sử dụng để xử lý và thay đổi yêu cầu và phản hồi trong quá trình xử lý request-response cycle. Chúng có thể được sử dụng để thực hiện các tác vụ như logging, biến đổi dữ liệu, hoặc thêm thông tin vào phản hồi.

2. **Thời Điểm Thực Thi**:
    - Interceptor thực thi trước và sau khi một phương thức xử lý (handler) được gọi.

3. **Cách Sử Dụng**:
    - Bạn có thể tạo một interceptor bằng cách implements `NestInterceptor` và sử dụng phương thức `intercept`.

4. **Ví Dụ**:
   ```typescript
   import {
     Injectable,
     NestInterceptor,
     ExecutionContext,
     CallHandler,
   } from '@nestjs/common';
   import { Observable } from 'rxjs';
   import { tap } from 'rxjs/operators';

   @Injectable()
   export class LoggingInterceptor implements NestInterceptor {
     intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
       const now = Date.now();
       return next
         .handle()
         .pipe(tap(() => console.log(`Request took: ${Date.now() - now}ms`)));
     }
   }
   ```

### Filter

1. **Mục Đích**:
    - Filter được sử dụng để xử lý các lỗi xảy ra trong quá trình xử lý yêu cầu. Chúng cho phép bạn quản lý các lỗi và gửi phản hồi lỗi theo cách tùy chỉnh.

2. **Thời Điểm Thực Thi**:
    - Filter chỉ thực thi khi một lỗi xảy ra trong quá trình xử lý yêu cầu.

3. **Cách Sử Dụng**:
    - Bạn có thể tạo một filter bằng cách implements `ExceptionFilter` và sử dụng phương thức `catch`.

4. **Ví Dụ**:
   ```typescript
   import {
     ExceptionFilter,
     Catch,
     ArgumentsHost,
     HttpException,
     HttpStatus,
   } from '@nestjs/common';
   import { Response } from 'express';

   @Catch()
   export class HttpExceptionFilter implements ExceptionFilter {
     catch(exception: unknown, host: ArgumentsHost) {
       const ctx = host.switchToHttp();
       const response = ctx.getResponse<Response>();
       const request = ctx.getRequest();
       
       const status =
         exception instanceof HttpException
           ? exception.getStatus()
           : HttpStatus.INTERNAL_SERVER_ERROR;

       const errorResponse = {
         statusCode: status,
         message: exception instanceof HttpException ? exception.getResponse() : 'Internal server error',
         timestamp: new Date().toISOString(),
         path: request.url,
       };

       response.status(status).json(errorResponse);
     }
   }
   ```

### Tóm Tắt Sự Khác Nhau

| Tiêu Chí         | Interceptor                          | Filter                             |
|------------------|--------------------------------------|------------------------------------|
| **Mục Đích**     | Thay đổi hoặc xử lý request/response | Xử lý lỗi                          |
| **Thời Điểm**    | Trước và sau khi xử lý handler      | Khi có lỗi xảy ra                   |
| **Sử Dụng**      | Khi cần thực hiện tác vụ như logging | Khi cần quản lý các phản hồi lỗi   |

### Kết Luận

Cả interceptor và filter đều hữu ích trong việc quản lý các yêu cầu và phản hồi trong ứng dụng NestJS. Bạn nên sử dụng interceptor để thay đổi dữ liệu và filter để xử lý lỗi một cách hiệu quả.